// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

//Shaders really like structures divisible by 128 bits, that's why our struct has dummy variables.
//https://developer.nvidia.com/content/understanding-structured-buffer-performance
//https://developer.nvidia.com/content/redundancy-and-latency-structured-buffer-use

//Each float in HLSL is 32bits (4bytes)
//https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-scalar

struct particle{
    float x;
    float y;
    float z;
    float dx;
    float dy;
    float dz;
    float dummy;
    float dummy2;
};

// RandomWrite Structured Buffer
RWStructuredBuffer<particle> particleBuffer;
uniform float timeDelta;
uniform float4 bounds;
uniform float airResistance;
uniform float initialVelocity;

float rand1dTo1d(float3 value, float mutator = 0.546f){
	float random = frac(sin(value + mutator) * 143758.5453f);
	return random;
}

float3 rand1dTo3d(float value){
    return float3(
        rand1dTo1d(value, 3.9812f),
        rand1dTo1d(value, 7.1536f),
        rand1dTo1d(value, 5.7241f)
    );
}

//because forces are being modified in parallel by different threads. 
//So, we need to use protected writing operation to avoid data loss. 
//But protected data access functions only work for int and uint values.
// https://www.reddit.com/r/Unity3D/comments/7ppldz/physics_simulation_on_gpu_with_compute_shader_in/
[numthreads(128,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float3 currentPosition = float3(particleBuffer[id.x].x, particleBuffer[id.x].y, particleBuffer[id.x].z);
    float3 previousPosition = float3(particleBuffer[id.x].dx, particleBuffer[id.x].dy, particleBuffer[id.x].dz);
    float3 tempPosition = currentPosition;
    float inverseMass = 1;
    float3 accumulatedForces = float3(0, -9.82, 0);

    //Verlet integration with a variable timestep does not really work. TODO: Another integration method is needed.
    currentPosition = (2 - airResistance) * currentPosition - (1-airResistance)*previousPosition + accumulatedForces * (timeDelta * timeDelta * inverseMass);
    
    particleBuffer[id.x].dx = tempPosition.x;
    particleBuffer[id.x].dy = tempPosition.y;
    particleBuffer[id.x].dz = tempPosition.z;

    particleBuffer[id.x].x = currentPosition.x;
    particleBuffer[id.x].y = currentPosition.y;
    particleBuffer[id.x].z = currentPosition.z;
}
