// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CalculatePressure
#pragma kernel CalculateAcceleration
#pragma kernel UpdateParticlePositions

//Shaders really like structures divisible by 128 bits, that's why our struct has dummy variables.
//https://developer.nvidia.com/content/understanding-structured-buffer-performance
//https://developer.nvidia.com/content/redundancy-and-latency-structured-buffer-use

//Each float in HLSL is 32bits (4bytes)
//https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-scalar

struct particle{
    float3 position;
    float density;
    float pressure;
    float lambda;
    float3 forces;
    float3 velocity;
};

// RandomWrite Structured Buffer
RWStructuredBuffer<particle> particleBuffer;
uniform float h;
uniform float pressureConstant;
uniform float referenceDensity;
uniform float viscosityConstant;
uniform float deltaTime;
uniform uint particleCount;
uniform float3 bounds;
uniform float3 externalForcePoint;
uniform float externalForceMagnitude;

//Poly6 smoothing kernel as described in M端ller et al. 2003
//"Particle-Based Fluid Simulation for Interactive Applications"
float Poly6(float3 r, float h){
    float r2 = dot(r,r);
    float W = h * h - r2;
    if (r2 > h*h) {
        return 0.0f;
    }
    return (315.0f / (64.0f * 3.1415f * pow(abs(h), 9))) * pow((W), 3);
}

//Calculating the gradient of the smoothing kernel "spiky" as described in M端ller et al. 2003
//"Particle-Based Fluid Simulation for Interactive Applications"
float3 gradientSpiky(float3 r, float h){
    float r2 = dot(r,r);

    if (r2 >= h*h)
        return float3(0,0,0);

    if (r2 <= 0.000001f)
        return float3(0,0,0);

    float radius = sqrt(r2);
    float spikyConstant = - (15 / (3.1415f * pow(h, 6))) * 3 * pow(h - radius, 2) / radius;
    return spikyConstant * r;
}

//because forces are being modified in parallel by different threads. 
//So, we need to use protected writing operation to avoid data loss. 
//But protected data access functions only work for int and uint values.
// https://www.reddit.com/r/Unity3D/comments/7ppldz/physics_simulation_on_gpu_with_compute_shader_in/

//Calculate lambda for each particle in the system.
[numthreads(1024,1,1)]
void CalculatePressure (uint3 id : SV_DispatchThreadID)
{
    //First calculate the density for each particle in the sytstem using the Poly6 smoothing kernel
    //M端ller et al. 2003 "Particle-Based Fluid Simulation for Interactive Applications"
    const float relaxationParameter = 1000.f;
    float density = 0;
    particle currentParticle = particleBuffer[id.x];
    float3 currentPosition = currentParticle.position;

    for(uint i = 0; i < particleCount; i++){
        float3 diff = currentPosition - particleBuffer[i].position;
        
        //We're assuming the mass to be 1. If not "+= mass * Poly6(diff, h)" would be
        //the correct density approximation.
        density += Poly6(diff, h);
    }

    //Using the computed particle density, calculate the density constraint for the given particle ( C_i(p_1, ..., p_n) )
    //as described in Miles, M & M端ller, M (2013) "Position Based Fluids".
    float densityConstraint = (density / referenceDensity) - 1;


    //Lambda is then calculated as the density constraint divided by the sum of
    //neighboring particles constraint gradients. Relaxation parameter epsilon used for better
    //stability when particles are close to seperating.
    float sumOfSquaredGradients = 0.0f;

    //  Accumulator for the case where k=i, i.e. the sum itself should be squared
    float3 grad_ki = float3(0,0,0);

    for(uint i = 0; i < particleCount; i++) {
        float3 diff = currentPosition - particleBuffer[i].position;
        float3 tmp_grad = gradientSpiky(diff, h);
        grad_ki += tmp_grad;

        if (i != id.x) {
            // k != i, the squared gradient should also be added directly to the denominator
            sumOfSquaredGradients += (tmp_grad.x * tmp_grad.x) + (tmp_grad.y * tmp_grad.y) + (tmp_grad.z * tmp_grad.z);
        }
    }

    sumOfSquaredGradients += + (grad_ki.x * grad_ki.x) + (grad_ki.y * grad_ki.y) + (grad_ki.z * grad_ki.z);

    // Compute lambda_i as -(C_i)/(sum(gradient of Ci)^2 + epsilon)
    float lambda = - densityConstraint / ((sumOfSquaredGradients / (referenceDensity * referenceDensity)) + relaxationParameter);
    particleBuffer[id.x].lambda = lambda;

    //Performance can be increased by using lookup tables instead of calculating
    //as seen in Bender, J & Koschier, D (2016) Divergence-Free SPH for Incompressible and Viscous Fluids
}

[numthreads(1024,1,1)]
void CalculateAcceleration (uint3 id : SV_DispatchThreadID)
{
    float3 position = particleBuffer[id.x].position;
    float3 deltaP = float3(0,0,0);

    for (uint i = 0; i < particleCount; i++) {
        float3 otherPosition = particleBuffer[i].position;

        float k = 0.005f;
        float deltaQ = 0.03f;
        int n = 4;
        float ONE_OVER_SQRT_OF_3 = 1 / sqrt(3);

        float sCorr = - k * pow(Poly6(position - otherPosition, h) / Poly6(float3(ONE_OVER_SQRT_OF_3 * deltaQ, ONE_OVER_SQRT_OF_3 * deltaQ, ONE_OVER_SQRT_OF_3 * deltaQ), h), n);
        deltaP += (particleBuffer[id.x].lambda + particleBuffer[i].lambda + sCorr) * gradientSpiky(position - otherPosition, h);

    }
    particleBuffer[id.x].position += clamp(deltaP, -0.4f, 0.4f);
}

[numthreads(1024,1,1)]
void UpdateParticlePositions (uint3 id : SV_DispatchThreadID)
{

}