// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CalculatePressure
#pragma kernel CalculateForces
#pragma kernel UpdateParticlePositions

#define PI 3.14159265

//Shaders really like structures divisible by 128 bits, that's why our struct has dummy variables.
//https://developer.nvidia.com/content/understanding-structured-buffer-performance
//https://developer.nvidia.com/content/redundancy-and-latency-structured-buffer-use

//Each float in HLSL is 32bits (4bytes)
//https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-scalar

struct particle{
    float3 position;
    float density;
    float pressure;
    float3 forces;
    float3 velocity;
};

// RandomWrite Structured Buffer
RWStructuredBuffer<particle> particleBuffer;
uniform float h;
uniform float gasConstant;
uniform float restDensity;
uniform float viscosityConstant;
uniform float deltaTime;
uniform uint particleCount;
uniform float3 bounds;
uniform float3 externalForcePoint;
uniform float externalForceMagnitude;
uniform float particleMass;
uniform float poly6Constant;
uniform float spikyConstant;
uniform float laplaceConstant;
uniform float3 gravity;
uniform float dampening;

uniform float3 planeNormal;
uniform float3 planePoint;

float Poly6Kernel(float rSqrd, float h){
    const float hSqrd = h * h;
    if(rSqrd < hSqrd)
        return particleMass * poly6Constant * pow(hSqrd - rSqrd, 3);
    return 0;
}

//because forces are being modified in parallel by different threads. 
//So, we need to use protected writing operation to avoid data loss. 
//But protected data access functions only work for int and uint values.
// https://www.reddit.com/r/Unity3D/comments/7ppldz/physics_simulation_on_gpu_with_compute_shader_in/
[numthreads(1024,1,1)]
void CalculatePressure (uint3 id : SV_DispatchThreadID){
    //Poly6 smoothing kernel to approximate fluid density. Eq. 3
    //Müller M, Charypar D & Gross M. 2003
    float3 currentPos = particleBuffer[id.x].position;
    float density = 0;

    for(uint i = 0; i < particleCount; i++){
        float3 otherPos = particleBuffer[i].position;
        float3 diff = otherPos - currentPos;
        float rSqrd = dot(diff, diff);
        if(rSqrd < h*h)
            density += Poly6Kernel(rSqrd, h);
    }

    //The pressure at the point of the particle can be calculated using Eq. 12 (Müller M, Charypar D & Gross M. 2003).
    particleBuffer[id.x].density = density;
    particleBuffer[id.x].pressure = gasConstant * (density - restDensity);
}

[numthreads(1024,1,1)]
void CalculateForces (uint3 id : SV_DispatchThreadID){
    const float h2 = h * h;
    const float h3 = h * h * h;

    float3 currentPos = particleBuffer[id.x].position;
    float3 pressureForce = float3(0,0,0);
    float3 viscosityForce = float3(0,0,0);


    //TODO: Seperate out the kernelsmoothing to a function.
    for (uint i = 0; i < particleCount; i++){
        if(i == id.x)   //Make sure we don't calculate forces for between self.
            continue;

        float3 otherPos = particleBuffer[i].position;

        float3 diff = currentPos - otherPos;
        float r2 = dot(diff, diff);
        float r = sqrt(r2);

        if (0 < r && r < h){
            float3 otherVelocity = particleBuffer[i].velocity;
            float otherDensity = particleBuffer[i].density;
            float otherPressure = particleBuffer[i].pressure;

            float W_spiky = spikyConstant * (h - r) * (h - r) * (h - r); // spiky kernel smoothing function (Eq. 21)
            pressureForce += particleMass * ((particleBuffer[id.x].pressure + otherPressure) / (2 * otherDensity)) * W_spiky * normalize(diff);

            //Calculating the viscosity force (Eq. 14)
            viscosityForce += particleMass * (otherVelocity - particleBuffer[id.x].velocity) / otherDensity * laplaceConstant * (h-r);
        }
    }

    pressureForce *= -1;
    viscosityForce *= viscosityConstant;
    particleBuffer[id.x].forces += (pressureForce + viscosityForce) / particleBuffer[id.x].density;
}

[numthreads(1024,1,1)]
void UpdateParticlePositions (uint3 id : SV_DispatchThreadID){
    particleBuffer[id.x].forces += gravity;

    float3 diff = externalForcePoint - particleBuffer[id.x].position;
    float rSqrd = dot(diff, diff);
    //Using smoothstep to smoothly reduce the force acting on each particle as a function of the distance between the particle and the cursor.
    particleBuffer[id.x].forces += (1.f-smoothstep(20.0f, 30.0f, rSqrd)) * (externalForcePoint - particleBuffer[id.x].position) * externalForceMagnitude;

    //Semi-implicit Euler integration.
    particleBuffer[id.x].velocity += particleBuffer[id.x].forces * deltaTime;
    particleBuffer[id.x].velocity *= (1 - dampening);
    particleBuffer[id.x].position += particleBuffer[id.x].velocity * deltaTime;

    //As a result of our bounding box being axis aligned, particle/bound collision is trivial to detect and correct.
    if(particleBuffer[id.x].position.x + h > bounds.x){
        particleBuffer[id.x].position.x = bounds.x - h;
        particleBuffer[id.x].velocity.x *= -0.6;
    }
    if(particleBuffer[id.x].position.x - h < -bounds.x){
        particleBuffer[id.x].position.x = -bounds.x + h;
        particleBuffer[id.x].velocity.x *= -0.6;
    }

    if(particleBuffer[id.x].position.z + h > bounds.z){
        particleBuffer[id.x].position.z = bounds.z - h;
        particleBuffer[id.x].velocity.z *= -0.6;
    }
    if(particleBuffer[id.x].position.z - h < -bounds.z){
        particleBuffer[id.x].position.z = -bounds.z + h;
        particleBuffer[id.x].velocity.z *= -0.6;
    }

    if (particleBuffer[id.x].position.y - h < 0){
        particleBuffer[id.x].position.y = h;
        particleBuffer[id.x].velocity.y *= -0.8;
    }

    // if(dot(planeNormal, (planePoint - particleBuffer[id.x].position)) < 0.0f){
    //     //Set particle position to a point that is projected on the plane and invert(?) the velocity.
    //     particleBuffer[id.x].position = particleBuffer[id.x].position - distance(particleBuffer[id.x].position, planePoint) * planeNormal;
    //     // particleBuffer[id.x].velocity *= reflect(particleBuffer[id.x].velocity, planeNormal) * 0.8f;
    // }

    particleBuffer[id.x].forces = float3(0,0,0);
}